### Node编程模式

Node采用的是非阻塞式的I/O和事件模式的编程模式

#### 非阻塞式I/O

 * 阻塞(block)：阻塞这个是针对线程的概念。线程在执行过程中如果遇到磁盘读写或者网络通信(统称I/O操作)需要耗费很长的时间，操作系统这时会收回这个线程对cpu的控制权，使其暂停执行，将资源让给其他的**工作线程**，这种线程调度方式就叫阻塞

    然后大家都知道JavaScript和Node都是单线程的，如果采用阻塞式的话，那么线程的CPU利用率就会非常的低,线程的运行时间线就像下面表示的一样，CPU计算的时间非常短，而I/O操作的时间一般是比较漫长的，采用阻塞式I/O的话，由于又是单线程，不像多线程，可以让给其他的线程。当操作I/O的时候只能等I/O操作结束才能继续后面的任务。

    线程任务时间线 ：  |-cpu-|---------I/O操作-------|--cpu--|-------I/O操作-------|

    就像上面显示的一样，I/O操作时非常耗时的，而cpu计算是很快的，特别是现在的CPU计算速度越来越快

    那么Node采取的就是和Nginx一样的事件驱动的模式

* 同步式IO或者阻塞式IO：当IO操作结束时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权

#### 事件驱动

事件驱动就是单线程下提高CPU利用率和支持阻塞式I/O的一种很好的解决方法。

具体过程抽象一下就是有一个主线程，主线程用来跑计算性任务(同步性操作)，异步操作会添加到一个事件队列(Event Queue)，首先我们做完主线程上面的操作，然后去轮询事件队列，看事件队列里面是否有I/O操作执行完了的，有就把这个回调添加到主线程去执行，执行完就就将这个事件从事件队列移除，否则继续轮询，直到队列为空为止。当然有错误欢迎指正。

如下图所示：

![Node事件模型图](http://7xrp7o.com1.z0.glb.clouddn.com/Event%20Drive.png)

#### Node的调用过程

首先Node API  -->  process.binding() 方法调用对应的c/c++编写的模块(libuv,v8等)

libuv是Node封装的一个库，实现了平台兼容性(Win, Linux, Unix)和模拟线程池等，是支持非阻塞I/O的重要支撑

v8是Chrome的js引擎，node坐上了这支火箭，性能也就窜窜窜的上来了

当然上面的这些都太底层了，想详细了解的可以去看源码[Node](https://github.com/nodejs/node)，没有c++基础的不建议，不然处处碰钉

我觉得咱们知道了，Node不能直接操作的内容，然后通过封装API，调用API也就是通过process.binding()去调用对应的c/c++模块就可以了，类似于下面的：

![Node fs模块系统调用](http://7xrp7o.com1.z0.glb.clouddn.com/fs.png)

![Node net模块系统调用](http://7xrp7o.com1.z0.glb.clouddn.com/net.png)

#### Node适用场景

通过上面的介绍，首先可以肯定的就是Node适合I/O密集型的引用，比如高并发的网络请求，比如实时通讯，网上促销之类的。
